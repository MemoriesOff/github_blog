---
layout: post
title: 智能车黑线提取算法
tags: 摄像头组 赛道提取 
categories: 飞思卡尔智能车竞赛
---
这是一篇针对**单行**的简单的黑线提取的文件。
#原始数据介绍
使用的OV7920摄像头通过DMA向单片机传输每个象素点的灰度值(0-255),为处理方便,一般以行列定义二维数组来处理.摄像头的对比度,分辨率等可以通过改变摄像头的参数来设置,这里采用常见的30*140
#二值化
要完成这一过程,首先需要确定阈值,高于这一阈值认为白线,低于则被认为黑线,值得注意的是,这只是数据的预处理,存在判断不准确的情况,后期还需加以判断.  
     
阈值的确定有两种方法,一种直接给定值,另一种则是根据对该行所有需要处理的数据取平均.后者在应对变化光线上有优势,但需要遍历所有数据确定阈值,速度较慢且无法通过该方法判断全黑线或全白线.  
     
其中FAV为阈值,point指针指向原始数据,二值化后的值将原始数据覆盖.
     
如果要实现动态阈值,一种基础的方法是:
```c
sum=0
for(int i=0;i<140;i++)
{
  sum+= *point1++;
}
FAV=sum/140;
```     
为与下文统一,这里FAV大写，正常情况下常量大写变量小写。
#查找左右边沿
从上一次的中点向左右两边扫，如果黑点的一定范围内黑点的个数满足要求，则判定该点为左右边线  
     
程序以左侧为例：
```c
for(temp0=centre_lastblack;temp0>5;temp0--)               //检测左侧边沿
{
  if(point[temp0]〉FAV)
  {
      continue；
  }
  for(temp1=temp0; temp1>( temp0-LINEWITH );temp1--)      //确认该点附近的黑点数是否满足要求
  {    
      if（point[temp1]<FAV）
          leftcount++;
  }    
  if(leftcount >= LINEWITH-DEVIATION )                        //判断是否满足边沿条件
  {
    leftedge = temp0 ;                                  //满足条件边沿找到
    leftflag=1;                                         //找到边沿，标志位置1 
    break;
  }
  else
  {
    leftcount=0;                                        //未找到清除计数  
    leftflag=0;                                         //未找到边沿，标志位置0
    leftedge=5;                                         // 边沿赋值 
  }
   
  if(leftedge<5) leftedge = 5;   
} 
```
由于摄像头采集到的数据边沿不准确，故最低值为5.  
     
#中点计算
对中点计算分为以下三种情况：
*左右均寻到
*仅寻到左线与右线
*左右线均未寻到
对于左右都寻到的情况，相加取平均是一种最简单的方法。  
    
仅寻到左线与右线时，以寻到的线的位置为基准，加减线宽的一半。

左右线都未寻到，默认上次中值  

值得说明的是，上述中点计算仅针对正常双线情况，对于存在赛道元素干扰的情况参见。
    
* * *
    
整车程序：[https://github.com/MemoriesOff/Freescale](https://github.com/MemoriesOff/Freescale)

为说明方便，文章中程序段与整车程序略有不同。
      
